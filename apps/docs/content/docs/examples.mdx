---
title: Examples
description: Real-world examples and patterns using react-usekit hooks and utilities
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Card, Cards } from "fumadocs-ui/components/card";

# üí° Real-World Examples

This page showcases practical examples of how to use react-usekit hooks and utilities in real applications.

<Callout title="Complete Examples">
  Each example includes complete, copy-pasteable code that you can use as a
  starting point for your own projects.
</Callout>

## Common Patterns

<Cards>
  <Card
    title="üîç Search with Debouncing"
    href="#search-with-debouncing"
    description="Auto-search with API calls and loading states"
  />
  <Card
    title="üõí Shopping Cart"
    href="#shopping-cart"
    description="Cart management with persistence and formatting"
  />
  <Card
    title="üìù Auto-Save Form"
    href="#auto-save-form"
    description="Form with localStorage persistence and validation"
  />
  <Card
    title="üåô Theme Switcher"
    href="#theme-switcher"
    description="Dark/light mode with system preference detection"
  />
  <Card
    title="üìä Data Dashboard"
    href="#data-dashboard"
    description="Real-time dashboard with auto-refresh"
  />
  <Card
    title="üéõÔ∏è User Settings"
    href="#user-settings"
    description="Comprehensive settings panel with persistence"
  />
</Cards>

## Search with Debouncing

A search component that combines `useAsync`, `useDebounce`, and `useLocalStorage` for a smooth search experience.

<Tabs items={['Complete Example', 'Component Breakdown']}>
<Tab value="Complete Example">
```tsx
import { useState, useEffect } from 'react';
import { useAsync } from './hooks/useAsync';
import { useDebounce } from './hooks/useDebounce';
import { useLocalStorage } from './hooks/useLocalStorage';
import { isEmpty, truncateText } from './lib/utils';

interface SearchResult {
id: string;
title: string;
description: string;
url: string;
category: string;
}

interface SearchHistory {
query: string;
timestamp: number;
}

function SmartSearch() {
const [query, setQuery] = useState('');
const [searchHistory, setSearchHistory] = useLocalStorage<SearchHistory[]>('searchHistory', []);
const debouncedQuery = useDebounce(query, 300);

const {
data: results,
loading,
error,
execute: search
} = useAsync<SearchResult[]>(
async () => {
if (isEmpty(debouncedQuery.trim())) {
return [];
}

      const response = await fetch(`/api/search?q=${encodeURIComponent(debouncedQuery)}&limit=10`);

      if (!response.ok) {
        throw new Error('Search failed. Please try again.');
      }

      const data = await response.json();

      // Save to search history
      const historyEntry: SearchHistory = {
        query: debouncedQuery,
        timestamp: Date.now()
      };

      setSearchHistory(prev => {
        const filtered = prev.filter(item => item.query !== debouncedQuery);
        return [historyEntry, ...filtered].slice(0, 10); // Keep last 10 searches
      });

      return data.results;
    },
    { immediate: false }

);

// Trigger search when debounced query changes
useEffect(() => {
if (debouncedQuery.length >= 2) {
search();
}
}, [debouncedQuery, search]);

const clearHistory = () => {
setSearchHistory([]);
};

const selectFromHistory = (historicalQuery: string) => {
setQuery(historicalQuery);
};

const showHistory = isEmpty(query) && !isEmpty(searchHistory);
const showResults = !isEmpty(query) && !loading;
const showNoResults = showResults && !isEmpty(query) && isEmpty(results);

return (

<div className="smart-search">
<div className="search-container">
<div className="search-input-wrapper">
<input
type="text"
value={query}
onChange={(e) => setQuery(e.target.value)}
placeholder="Search articles, tutorials, and more..."
className="search-input"
/>
{loading && <div className="search-spinner">üîç</div>}
</div>

        {error && (
          <div className="search-error">
            ‚ùå {error.message}
          </div>
        )}

        {showHistory && (
          <div className="search-history">
            <div className="history-header">
              <h4>Recent Searches</h4>
              <button onClick={clearHistory} className="clear-history">
                Clear
              </button>
            </div>
            <div className="history-list">
              {searchHistory.map((item) => (
                <button
                  key={item.timestamp}
                  onClick={() => selectFromHistory(item.query)}
                  className="history-item"
                >
                  <span>üïí</span>
                  <span>{item.query}</span>
                </button>
              ))}
            </div>
          </div>
        )}

        {showResults && results && results.length > 0 && (
          <div className="search-results">
            <div className="results-header">
              <span>{results.length} results for "{query}"</span>
            </div>
            <div className="results-list">
              {results.map((result) => (
                <a
                  key={result.id}
                  href={result.url}
                  className="result-item"
                >
                  <div className="result-category">{result.category}</div>
                  <h3 className="result-title">{result.title}</h3>
                  <p className="result-description">
                    {truncateText(result.description, 120)}
                  </p>
                </a>
              ))}
            </div>
          </div>
        )}

        {showNoResults && (
          <div className="no-results">
            <p>No results found for "{query}"</p>
            <p>Try different keywords or check your spelling.</p>
          </div>
        )}
      </div>
    </div>

);
}

export default SmartSearch;
```
</Tab>
<Tab value="Component Breakdown">
**Hooks Used:**
- `useAsync` - Handles search API calls with loading/error states
- `useDebounce` - Delays search execution to avoid excessive API calls  
- `useLocalStorage` - Persists search history across sessions

**Utilities Used:**

- `isEmpty` - Validates query and results
- `truncateText` - Limits description length for better UI

**Key Features:**

- ‚è±Ô∏è 300ms debounce delay for optimal performance
- üíæ Persistent search history (last 10 searches)
- üîÑ Auto-search when typing (minimum 2 characters)
- ‚ùå Graceful error handling with retry capability
- üì± Responsive design with loading indicators

**Performance Optimizations:**

- Debounced API calls reduce server load
- Search history prevents duplicate entries
- Results are cached until new search
- Component re-renders are minimized

</Tab>
</Tabs>

## Shopping Cart

A complete shopping cart implementation with persistence, formatting, and complex state management.

<Tabs items={['Cart Component', 'Cart Hook', 'Item Component']}>
<Tab value="Cart Component">
```tsx
import { useShoppingCart } from './hooks/useShoppingCart';
import { formatCurrency, isEmpty } from './lib/utils';

interface Product {
id: string;
name: string;
price: number;
image: string;
category: string;
}

function ShoppingCart() {
const {
items,
addItem,
removeItem,
updateQuantity,
clearCart,
cartTotal,
itemCount,
isCartEmpty
} = useShoppingCart();

const taxRate = 0.08; // 8% tax
const shippingThreshold = 50;
const shippingCost = cartTotal >= shippingThreshold ? 0 : 9.99;
const tax = cartTotal \* taxRate;
const finalTotal = cartTotal + tax + shippingCost;

if (isCartEmpty) {
return (

<div className="empty-cart">
  <div className="empty-cart-icon">üõí</div>
  <h2>Your cart is empty</h2>
  <p>Add some items to get started!</p>
</div>
); }

return (

<div className="shopping-cart">
<div className="cart-header">
<h2>Shopping Cart ({itemCount} items)</h2>
<button onClick={clearCart} className="clear-cart">
Clear Cart
</button>
</div>

      <div className="cart-items">
        {items.map(item => (
          <CartItem
            key={item.id}
            item={item}
            onUpdateQuantity={updateQuantity}
            onRemove={removeItem}
          />
        ))}
      </div>

      <div className="cart-summary">
        <div className="summary-line">
          <span>Subtotal:</span>
          <span>{formatCurrency(cartTotal)}</span>
        </div>

        <div className="summary-line">
          <span>Tax ({(taxRate * 100).toFixed(1)}%):</span>
          <span>{formatCurrency(tax)}</span>
        </div>

        <div className="summary-line">
          <span>Shipping:</span>
          <span>
            {shippingCost === 0 ? (
              <span className="free-shipping">Free</span>
            ) : (
              formatCurrency(shippingCost)
            )}
          </span>
        </div>

        {cartTotal < shippingThreshold && (
          <div className="shipping-notice">
            Add {formatCurrency(shippingThreshold - cartTotal)} more for free shipping!
          </div>
        )}

        <div className="summary-line total">
          <span><strong>Total:</strong></span>
          <span><strong>{formatCurrency(finalTotal)}</strong></span>
        </div>

        <button className="checkout-button">
          Proceed to Checkout
        </button>
      </div>
    </div>

);
}

function CartItem({ item, onUpdateQuantity, onRemove }) {
return (

<div className="cart-item">
<img src={item.image} alt={item.name} className="item-image" />

      <div className="item-details">
        <h3 className="item-name">{item.name}</h3>
        <p className="item-category">{item.category}</p>
        <p className="item-price">{formatCurrency(item.price)}</p>
      </div>

      <div className="quantity-controls">
        <button
          onClick={() => onUpdateQuantity(item.id, item.quantity - 1)}
          disabled={item.quantity <= 1}
          className="quantity-btn"
        >
          ‚àí
        </button>
        <span className="quantity">{item.quantity}</span>
        <button
          onClick={() => onUpdateQuantity(item.id, item.quantity + 1)}
          className="quantity-btn"
        >
          +
        </button>
      </div>

      <div className="item-total">
        {formatCurrency(item.price * item.quantity)}
      </div>

      <button
        onClick={() => onRemove(item.id)}
        className="remove-btn"
        aria-label="Remove item"
      >
        üóëÔ∏è
      </button>
    </div>

);
}

````
</Tab>
<Tab value="Cart Hook">
```tsx
import { useLocalStorage } from './useLocalStorage';
import { generateId, deepClone, isEmpty } from '../lib/utils';

interface CartItem {
  id: string;
  productId: string;
  name: string;
  price: number;
  quantity: number;
  image: string;
  category: string;
  addedAt: number;
}

interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
  category: string;
}

export function useShoppingCart() {
  const [items, setItems] = useLocalStorage<CartItem[]>('shoppingCart', []);

  const addItem = (product: Product, quantity: number = 1) => {
    setItems(prevItems => {
      const existingItem = prevItems.find(item => item.productId === product.id);

      if (existingItem) {
        // Update existing item quantity
        return prevItems.map(item =>
          item.productId === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }

      // Add new item
      const newItem: CartItem = {
        id: generateId(),
        productId: product.id,
        name: product.name,
        price: product.price,
        quantity,
        image: product.image,
        category: product.category,
        addedAt: Date.now()
      };

      return [...prevItems, newItem];
    });
  };

  const removeItem = (itemId: string) => {
    setItems(prevItems => prevItems.filter(item => item.id !== itemId));
  };

  const updateQuantity = (itemId: string, newQuantity: number) => {
    if (newQuantity <= 0) {
      removeItem(itemId);
      return;
    }

    setItems(prevItems =>
      prevItems.map(item =>
        item.id === itemId ? { ...item, quantity: newQuantity } : item
      )
    );
  };

  const clearCart = () => {
    setItems([]);
  };

  const getItemQuantity = (productId: string): number => {
    const item = items.find(item => item.productId === productId);
    return item ? item.quantity : 0;
  };

  // Computed values
  const cartTotal = items.reduce((total, item) => total + (item.price * item.quantity), 0);
  const itemCount = items.reduce((count, item) => count + item.quantity, 0);
  const isCartEmpty = isEmpty(items);
  const uniqueItemCount = items.length;

  return {
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    getItemQuantity,
    cartTotal,
    itemCount,
    uniqueItemCount,
    isCartEmpty
  };
}
````

</Tab>
<Tab value="Item Component">
```tsx
import { useShoppingCart } from './hooks/useShoppingCart';
import { formatCurrency, truncateText } from './lib/utils';

interface Product {
id: string;
name: string;
price: number;
image: string;
category: string;
description: string;
rating: number;
reviewCount: number;
}

function ProductCard({ product }: { product: Product }) {
const { addItem, getItemQuantity } = useShoppingCart();
const quantityInCart = getItemQuantity(product.id);

const handleAddToCart = () => {
addItem(product);
};

return (

<div className="product-card">
<div className="product-image-container">
<img src={product.image} alt={product.name} className="product-image" />
{quantityInCart > 0 && (
<div className="cart-badge">
{quantityInCart} in cart
</div>
)}
</div>

      <div className="product-info">
        <div className="product-category">{product.category}</div>
        <h3 className="product-name">{product.name}</h3>
        <p className="product-description">
          {truncateText(product.description, 100)}
        </p>

        <div className="product-rating">
          <span className="stars">{'‚òÖ'.repeat(Math.floor(product.rating))}</span>
          <span className="rating-text">
            {product.rating} ({product.reviewCount} reviews)
          </span>
        </div>

        <div className="product-footer">
          <div className="product-price">
            {formatCurrency(product.price)}
          </div>

          <button
            onClick={handleAddToCart}
            className="add-to-cart-btn"
          >
            {quantityInCart > 0 ? 'Add Another' : 'Add to Cart'}
          </button>
        </div>
      </div>
    </div>

);
}

// Usage in a product listing
function ProductGrid({ products }: { products: Product[] }) {
const { itemCount } = useShoppingCart();

return (

<div className="product-grid-container">
<div className="grid-header">
<h2>Products</h2>
{itemCount > 0 && (
<div className="cart-indicator">
üõí {itemCount} items in cart
</div>
)}
</div>

      <div className="product-grid">
        {products.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>

);
}

````
</Tab>
</Tabs>

## Auto-Save Form

A form that automatically saves to localStorage as the user types, with validation and recovery.

```tsx
import { useState, useEffect } from 'react';
import { useLocalStorage } from './hooks/useLocalStorage';
import { useDebounce } from './hooks/useDebounce';
import { useAsync } from './hooks/useAsync';
import { isEmpty, capitalize, generateId } from './lib/utils';

interface BlogPost {
  id?: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  status: 'draft' | 'published';
  lastSaved?: number;
}

function BlogEditor({ postId }: { postId?: string }) {
  const [post, setPost] = useLocalStorage<BlogPost>(`blogPost_${postId || 'new'}`, {
    title: '',
    content: '',
    category: '',
    tags: [],
    status: 'draft'
  });

  const [lastSaved, setLastSaved] = useState<number | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [tagInput, setTagInput] = useState('');

  // Debounce the post data to avoid excessive saves
  const debouncedPost = useDebounce(post, 1000);

  // Auto-save to server
  const {
    loading: saving,
    error: saveError,
    execute: saveToServer
  } = useAsync(
    async () => {
      const postData = {
        ...debouncedPost,
        id: debouncedPost.id || generateId(),
        lastSaved: Date.now()
      };

      const response = await fetch(`/api/posts/${postData.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(postData)
      });

      if (!response.ok) {
        throw new Error('Failed to save post');
      }

      return response.json();
    },
    {
      immediate: false,
      onSuccess: () => {
        setLastSaved(Date.now());
        setHasUnsavedChanges(false);
      }
    }
  );

  // Auto-save when content changes
  useEffect(() => {
    if (!isEmpty(debouncedPost.title) || !isEmpty(debouncedPost.content)) {
      saveToServer();
      setHasUnsavedChanges(true);
    }
  }, [debouncedPost, saveToServer]);

  // Warn before leaving with unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = '';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [hasUnsavedChanges]);

  const updatePost = (updates: Partial<BlogPost>) => {
    setPost(prev => ({ ...prev, ...updates }));
    setHasUnsavedChanges(true);
  };

  const addTag = () => {
    if (!isEmpty(tagInput.trim()) && !post.tags.includes(tagInput.trim())) {
      updatePost({
        tags: [...post.tags, tagInput.trim().toLowerCase()]
      });
      setTagInput('');
    }
  };

  const removeTag = (tagToRemove: string) => {
    updatePost({
      tags: post.tags.filter(tag => tag !== tagToRemove)
    });
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && e.target === document.activeElement) {
      e.preventDefault();
      addTag();
    }
  };

  const publish = async () => {
    if (isEmpty(post.title) || isEmpty(post.content)) {
      alert('Please add a title and content before publishing');
      return;
    }

    updatePost({ status: 'published' });
    await saveToServer();
  };

  return (
    <div className="blog-editor">
      <div className="editor-header">
        <h1>Blog Editor</h1>
        <div className="editor-status">
          {saving && <span className="saving">üíæ Saving...</span>}
          {saveError && <span className="error">‚ùå Save failed</span>}
          {lastSaved && !saving && !saveError && (
            <span className="saved">
              ‚úÖ Saved {new Date(lastSaved).toLocaleTimeString()}
            </span>
          )}
        </div>
      </div>

      <div className="editor-form">
        <div className="form-group">
          <label htmlFor="title">Title</label>
          <input
            id="title"
            type="text"
            value={post.title}
            onChange={(e) => updatePost({ title: e.target.value })}
            placeholder="Enter your blog post title..."
            className="title-input"
          />
        </div>

        <div className="form-group">
          <label htmlFor="category">Category</label>
          <select
            id="category"
            value={post.category}
            onChange={(e) => updatePost({ category: e.target.value })}
            className="category-select"
          >
            <option value="">Select a category</option>
            <option value="technology">Technology</option>
            <option value="design">Design</option>
            <option value="business">Business</option>
            <option value="lifestyle">Lifestyle</option>
          </select>
        </div>

        <div className="form-group">
          <label>Tags</label>
          <div className="tags-input-container">
            <input
              type="text"
              value={tagInput}
              onChange={(e) => setTagInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Add tags..."
              className="tag-input"
            />
            <button type="button" onClick={addTag} className="add-tag-btn">
              Add
            </button>
          </div>
          <div className="tags-list">
            {post.tags.map(tag => (
              <span key={tag} className="tag">
                {capitalize(tag)}
                <button onClick={() => removeTag(tag)} className="remove-tag">
                  √ó
                </button>
              </span>
            ))}
          </div>
        </div>

        <div className="form-group">
          <label htmlFor="content">Content</label>
          <textarea
            id="content"
            value={post.content}
            onChange={(e) => updatePost({ content: e.target.value })}
            placeholder="Write your blog post content here..."
            className="content-textarea"
            rows={15}
          />
        </div>

        <div className="editor-actions">
          <button
            onClick={() => updatePost({ status: 'draft' })}
            className="save-draft-btn"
            disabled={saving}
          >
            Save as Draft
          </button>

          <button
            onClick={publish}
            className="publish-btn"
            disabled={saving || isEmpty(post.title) || isEmpty(post.content)}
          >
            {post.status === 'published' ? 'Update Published Post' : 'Publish'}
          </button>
        </div>
      </div>
    </div>
  );
}
````

## Best Practices Summary

<Callout type="info" title="Key Patterns">
These examples demonstrate several important patterns:

- **Combine Multiple Hooks**: Use hooks together for powerful functionality
- **Handle Edge Cases**: Always validate inputs and handle empty states
- **Optimize Performance**: Use debouncing and memoization appropriately
- **Provide Feedback**: Show loading states and error messages
- **Persist Important Data**: Use localStorage for user preferences and form data
- **Follow Accessibility**: Include proper labels, ARIA attributes, and keyboard navigation

</Callout>

### Common Hook Combinations

- `useAsync` + `useDebounce` = Efficient search and API calls
- `useLocalStorage` + `useToggle` = Persistent UI state
- `useAsync` + `useLocalStorage` = Cached API responses
- `useClickOutside` + `useToggle` = Modal and dropdown patterns
- `useWindowSize` + `useDebounce` = Responsive components

### Performance Considerations

1. **Debounce User Input** - Prevent excessive API calls and updates
2. **Memoize Expensive Operations** - Cache computed values and formatters
3. **Batch State Updates** - Update multiple values together when possible
4. **Cleanup Side Effects** - Most hooks handle this automatically
5. **Use TypeScript** - Catch errors early and improve developer experience

Want to see more examples? Check out the individual hook and utility documentation pages for specific use cases and implementation details!

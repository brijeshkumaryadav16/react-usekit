---
title: useEventListener
description: Add and remove event listeners with automatic cleanup
---

# useEventListener

The `useEventListener` hook provides a simple way to add event listeners to DOM elements, the
window, or document with automatic cleanup when the component unmounts. It handles all the
boilerplate of adding and removing event listeners safely.

## Usage

```tsx
import { useEventListener } from './hooks/useEventListener';

function Component() {
  const handleKeyPress = (event: KeyboardEvent) => {
    if (event.key === 'Escape') {
      console.log('Escape key pressed!');
    }
  };

  useEventListener('keydown', handleKeyPress);

  return <div>Press Escape key</div>;
}
```

## API Reference

### Parameters

- `eventName` (string): The name of the event to listen for
- `handler` (function): The event handler function
- `element` (Element | Window | Document, optional): The target element. Defaults to `window`

### Returns

This hook doesn't return any value.

## Examples

### Keyboard Shortcuts

```tsx
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);

  const handleKeyDown = (event: KeyboardEvent) => {
    // Escape key closes modals
    if (event.key === 'Escape') {
      setIsModalOpen(false);
      setIsSidebarOpen(false);
    }

    // Ctrl/Cmd + K opens search
    if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
      event.preventDefault();
      openSearch();
    }

    // Ctrl/Cmd + B toggles sidebar
    if ((event.ctrlKey || event.metaKey) && event.key === 'b') {
      event.preventDefault();
      setIsSidebarOpen(prev => !prev);
    }
  };

  useEventListener('keydown', handleKeyDown);

  return (
    <div className="app">
      <button onClick={() => setIsModalOpen(true)}>Open Modal (Escape to close)</button>

      <div className="shortcuts">
        <p>Keyboard Shortcuts:</p>
        <ul>
          <li>Escape - Close modals</li>
          <li>Ctrl/Cmd + K - Search</li>
          <li>Ctrl/Cmd + B - Toggle sidebar</li>
        </ul>
      </div>

      {isModalOpen && <Modal onClose={() => setIsModalOpen(false)} />}
      {isSidebarOpen && <Sidebar />}
    </div>
  );
}
```

### Window Resize Handler

```tsx
function ResponsiveComponent() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  const handleResize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight,
    });
  };

  useEventListener('resize', handleResize);

  return (
    <div>
      <p>
        Window size: {windowSize.width} x {windowSize.height}
      </p>
      <div className={windowSize.width < 768 ? 'mobile-layout' : 'desktop-layout'}>
        Content adapts to screen size
      </div>
    </div>
  );
}
```

### Scroll Position Tracking

```tsx
function ScrollProgress() {
  const [scrollProgress, setScrollProgress] = useState(0);

  const handleScroll = () => {
    const scrollTop = window.pageYOffset;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const scrollPercent = (scrollTop / docHeight) * 100;
    setScrollProgress(scrollPercent);
  };

  useEventListener('scroll', handleScroll);

  return (
    <div className="scroll-progress">
      <div className="progress-bar" style={{ width: `${scrollProgress}%` }} />
      <p>Scroll progress: {Math.round(scrollProgress)}%</p>
    </div>
  );
}
```

### Mouse Position Tracker

```tsx
function MouseTracker() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (event: MouseEvent) => {
    setMousePosition({
      x: event.clientX,
      y: event.clientY,
    });
  };

  useEventListener('mousemove', handleMouseMove);

  return (
    <div className="mouse-tracker">
      <p>
        Mouse position: {mousePosition.x}, {mousePosition.y}
      </p>
      <div
        className="cursor-dot"
        style={{
          position: 'fixed',
          left: mousePosition.x,
          top: mousePosition.y,
          width: '10px',
          height: '10px',
          backgroundColor: 'red',
          borderRadius: '50%',
          pointerEvents: 'none',
          zIndex: 9999,
        }}
      />
    </div>
  );
}
```

### Click Outside Detection

```tsx
function DropdownMenu() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const handleClickOutside = (event: MouseEvent) => {
    if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
      setIsOpen(false);
    }
  };

  useEventListener('mousedown', handleClickOutside, document);

  return (
    <div ref={dropdownRef} className="dropdown">
      <button onClick={() => setIsOpen(!isOpen)}>Toggle Menu</button>

      {isOpen && (
        <div className="dropdown-menu">
          <ul>
            <li>Option 1</li>
            <li>Option 2</li>
            <li>Option 3</li>
          </ul>
        </div>
      )}
    </div>
  );
}
```

### Online/Offline Status

```tsx
function OnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  const handleOnline = () => setIsOnline(true);
  const handleOffline = () => setIsOnline(false);

  useEventListener('online', handleOnline);
  useEventListener('offline', handleOffline);

  return (
    <div className={`status ${isOnline ? 'online' : 'offline'}`}>
      <span className="indicator" />
      {isOnline ? 'Online' : 'Offline'}
    </div>
  );
}
```

### Form Auto-save

```tsx
function AutoSaveForm() {
  const [formData, setFormData] = useState({ title: '', content: '' });
  const [isDirty, setIsDirty] = useState(false);

  const handleBeforeUnload = (event: BeforeUnloadEvent) => {
    if (isDirty) {
      event.preventDefault();
      event.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
    }
  };

  useEventListener('beforeunload', handleBeforeUnload);

  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    setIsDirty(true);
  };

  const handleSave = async () => {
    await saveForm(formData);
    setIsDirty(false);
  };

  return (
    <form className="auto-save-form">
      <input
        value={formData.title}
        onChange={e => handleInputChange('title', e.target.value)}
        placeholder="Title"
      />
      <textarea
        value={formData.content}
        onChange={e => handleInputChange('content', e.target.value)}
        placeholder="Content"
      />

      <div className="form-actions">
        <button type="button" onClick={handleSave}>
          Save {isDirty && '(unsaved changes)'}
        </button>
      </div>
    </form>
  );
}
```

### Custom Element Events

```tsx
function CustomElementListener() {
  const elementRef = useRef<HTMLDivElement>(null);
  const [customEventData, setCustomEventData] = useState(null);

  const handleCustomEvent = (event: CustomEvent) => {
    setCustomEventData(event.detail);
  };

  useEventListener('customEvent', handleCustomEvent, elementRef.current);

  const triggerCustomEvent = () => {
    if (elementRef.current) {
      const event = new CustomEvent('customEvent', {
        detail: { message: 'Custom event triggered!', timestamp: Date.now() },
      });
      elementRef.current.dispatchEvent(event);
    }
  };

  return (
    <div ref={elementRef} className="custom-element">
      <button onClick={triggerCustomEvent}>Trigger Custom Event</button>

      {customEventData && (
        <div className="event-data">
          <p>Event Data: {JSON.stringify(customEventData)}</p>
        </div>
      )}
    </div>
  );
}
```

### Focus Management

```tsx
function FocusManager() {
  const [focusHistory, setFocusHistory] = useState<string[]>([]);

  const handleFocusIn = (event: FocusEvent) => {
    const target = event.target as HTMLElement;
    const elementInfo = `${target.tagName.toLowerCase()}${
      target.id ? `#${target.id}` : ''
    }${target.className ? `.${target.className}` : ''}`;

    setFocusHistory(prev => [...prev.slice(-4), elementInfo]);
  };

  useEventListener('focusin', handleFocusIn, document);

  return (
    <div className="focus-manager">
      <h3>Focus History</h3>
      <ul>
        {focusHistory.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>

      <div className="test-elements">
        <input placeholder="Input 1" />
        <input placeholder="Input 2" />
        <button>Button 1</button>
        <button>Button 2</button>
        <textarea placeholder="Textarea"></textarea>
      </div>
    </div>
  );
}
```

### Media Query Listener

```tsx
function MediaQueryListener() {
  const [matches, setMatches] = useState({
    mobile: false,
    tablet: false,
    desktop: false,
  });

  useEffect(() => {
    const mediaQueries = {
      mobile: window.matchMedia('(max-width: 767px)'),
      tablet: window.matchMedia('(min-width: 768px) and (max-width: 1023px)'),
      desktop: window.matchMedia('(min-width: 1024px)'),
    };

    const updateMatches = () => {
      setMatches({
        mobile: mediaQueries.mobile.matches,
        tablet: mediaQueries.tablet.matches,
        desktop: mediaQueries.desktop.matches,
      });
    };

    // Initial check
    updateMatches();

    // Add listeners
    Object.values(mediaQueries).forEach(mq => {
      mq.addEventListener('change', updateMatches);
    });

    return () => {
      Object.values(mediaQueries).forEach(mq => {
        mq.removeEventListener('change', updateMatches);
      });
    };
  }, []);

  return (
    <div className="media-query-listener">
      <h3>Current Breakpoint</h3>
      <ul>
        <li>Mobile: {matches.mobile ? '✓' : '✗'}</li>
        <li>Tablet: {matches.tablet ? '✓' : '✗'}</li>
        <li>Desktop: {matches.desktop ? '✓' : '✗'}</li>
      </ul>
    </div>
  );
}
```

## Notes

- Automatically adds the event listener when the component mounts
- Automatically removes the event listener when the component unmounts
- The event handler is automatically updated when it changes
- Supports any DOM event on any element, window, or document
- Perfect for global event handling like keyboard shortcuts, window events, etc.
- Use the element parameter to target specific DOM elements

---
title: deepClone
description: Create deep copies of objects and arrays safely
---

# deepClone

The `deepClone` utility function creates a deep copy of objects and arrays, ensuring that nested properties are also cloned rather than referenced. This is essential for state management, data manipulation, and avoiding unintended mutations.

## Usage

```javascript
import { deepClone } from "./utils/deepClone";

const original = {
  name: "John",
  address: {
    street: "123 Main St",
    city: "New York",
  },
  hobbies: ["reading", "gaming"],
};

const cloned = deepClone(original);
cloned.address.city = "Boston";
cloned.hobbies.push("cooking");

console.log(original.address.city); // 'New York' (unchanged)
console.log(cloned.address.city); // 'Boston'
```

## API Reference

### Parameters

- `obj` (any): The object or array to deep clone

### Returns

- `any`: A deep copy of the input

## Examples

### State Management

```javascript
function UserProfileEditor() {
  const [originalProfile, setOriginalProfile] = useState({
    personal: {
      name: "John Doe",
      email: "john@example.com",
      avatar: "avatar.jpg",
    },
    settings: {
      notifications: true,
      privacy: "public",
      theme: "light",
    },
    preferences: {
      language: "en",
      timezone: "UTC",
      dateFormat: "MM/DD/YYYY",
    },
  });

  const [editingProfile, setEditingProfile] = useState(() =>
    deepClone(originalProfile)
  );
  const [hasChanges, setHasChanges] = useState(false);

  const updateProfile = (section, field, value) => {
    setEditingProfile((prev) => {
      const updated = deepClone(prev);
      updated[section][field] = value;
      return updated;
    });
    setHasChanges(true);
  };

  const saveChanges = () => {
    setOriginalProfile(deepClone(editingProfile));
    setHasChanges(false);
  };

  const cancelChanges = () => {
    setEditingProfile(deepClone(originalProfile));
    setHasChanges(false);
  };

  return (
    <div className="profile-editor">
      <div className="editor-section">
        <h3>Personal Information</h3>
        <input
          value={editingProfile.personal.name}
          onChange={(e) => updateProfile("personal", "name", e.target.value)}
          placeholder="Name"
        />
        <input
          value={editingProfile.personal.email}
          onChange={(e) => updateProfile("personal", "email", e.target.value)}
          placeholder="Email"
        />
      </div>

      <div className="editor-section">
        <h3>Settings</h3>
        <label>
          <input
            type="checkbox"
            checked={editingProfile.settings.notifications}
            onChange={(e) =>
              updateProfile("settings", "notifications", e.target.checked)
            }
          />
          Enable Notifications
        </label>
        <select
          value={editingProfile.settings.theme}
          onChange={(e) => updateProfile("settings", "theme", e.target.value)}
        >
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>

      <div className="editor-actions">
        <button onClick={saveChanges} disabled={!hasChanges}>
          Save Changes
        </button>
        <button onClick={cancelChanges} disabled={!hasChanges}>
          Cancel
        </button>
      </div>
    </div>
  );
}
```

### Undo/Redo System

```javascript
function useUndoRedo(initialState) {
  const [history, setHistory] = useState([deepClone(initialState)]);
  const [currentIndex, setCurrentIndex] = useState(0);

  const currentState = history[currentIndex];

  const setState = useCallback(
    (newState) => {
      setHistory((prev) => {
        const newHistory = prev.slice(0, currentIndex + 1);
        newHistory.push(deepClone(newState));
        return newHistory;
      });
      setCurrentIndex((prev) => prev + 1);
    },
    [currentIndex]
  );

  const undo = useCallback(() => {
    if (currentIndex > 0) {
      setCurrentIndex((prev) => prev - 1);
    }
  }, [currentIndex]);

  const redo = useCallback(() => {
    if (currentIndex < history.length - 1) {
      setCurrentIndex((prev) => prev + 1);
    }
  }, [currentIndex, history.length]);

  const canUndo = currentIndex > 0;
  const canRedo = currentIndex < history.length - 1;

  return {
    state: currentState,
    setState,
    undo,
    redo,
    canUndo,
    canRedo,
  };
}

function DrawingApp() {
  const [drawing, setDrawing] = useUndoRedo({
    shapes: [],
    selectedTool: "pen",
    strokeColor: "#000000",
    strokeWidth: 2,
  });

  const addShape = (shape) => {
    setDrawing({
      ...drawing,
      shapes: [...drawing.shapes, shape],
    });
  };

  return (
    <div className="drawing-app">
      <div className="toolbar">
        <button onClick={undo} disabled={!canUndo}>
          Undo
        </button>
        <button onClick={redo} disabled={!canRedo}>
          Redo
        </button>
      </div>
      <Canvas drawing={drawing} onAddShape={addShape} />
    </div>
  );
}
```

### Form Data Manipulation

```javascript
function MultiStepForm() {
  const [formData, setFormData] = useState({
    step1: { name: "", email: "" },
    step2: { address: "", city: "", zipCode: "" },
    step3: { preferences: [], notifications: true },
  });
  const [currentStep, setCurrentStep] = useState(1);

  const updateStepData = (step, data) => {
    setFormData((prev) => {
      const updated = deepClone(prev);
      updated[`step${step}`] = { ...updated[`step${step}`], ...data };
      return updated;
    });
  };

  const addPreference = (preference) => {
    setFormData((prev) => {
      const updated = deepClone(prev);
      updated.step3.preferences.push(preference);
      return updated;
    });
  };

  const removePreference = (index) => {
    setFormData((prev) => {
      const updated = deepClone(prev);
      updated.step3.preferences.splice(index, 1);
      return updated;
    });
  };

  const resetForm = () => {
    setFormData({
      step1: { name: "", email: "" },
      step2: { address: "", city: "", zipCode: "" },
      step3: { preferences: [], notifications: true },
    });
    setCurrentStep(1);
  };

  return (
    <div className="multi-step-form">
      {currentStep === 1 && (
        <Step1
          data={formData.step1}
          onUpdate={(data) => updateStepData(1, data)}
          onNext={() => setCurrentStep(2)}
        />
      )}
      {/* Other steps... */}
    </div>
  );
}
```

### API Response Caching

```javascript
function useApiCache() {
  const [cache, setCache] = useState({});

  const getCachedData = (key) => {
    const cached = cache[key];
    if (cached && Date.now() - cached.timestamp < 5 * 60 * 1000) {
      // 5 minutes
      return deepClone(cached.data);
    }
    return null;
  };

  const setCachedData = (key, data) => {
    setCache((prev) => ({
      ...prev,
      [key]: {
        data: deepClone(data),
        timestamp: Date.now(),
      },
    }));
  };

  const clearCache = () => {
    setCache({});
  };

  return {
    getCachedData,
    setCachedData,
    clearCache,
  };
}

function DataFetcher({ url }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const { getCachedData, setCachedData } = useApiCache();

  useEffect(() => {
    const cachedData = getCachedData(url);
    if (cachedData) {
      setData(cachedData);
      setLoading(false);
      return;
    }

    fetch(url)
      .then((response) => response.json())
      .then((responseData) => {
        setCachedData(url, responseData);
        setData(deepClone(responseData));
      })
      .finally(() => setLoading(false));
  }, [url]);

  return loading ? <div>Loading...</div> : <DataDisplay data={data} />;
}
```

### Complex Data Transformations

```javascript
function DataTransformer({ sourceData }) {
  const [transformedData, setTransformedData] = useState([]);

  useEffect(() => {
    if (!sourceData) return;

    const transformed = sourceData.map((item) => {
      const cloned = deepClone(item);

      // Add computed fields
      cloned.fullName = `${cloned.firstName} ${cloned.lastName}`;
      cloned.age = calculateAge(cloned.birthDate);

      // Transform nested arrays
      if (cloned.orders) {
        cloned.orders = cloned.orders.map((order) => ({
          ...order,
          total: order.items.reduce(
            (sum, item) => sum + item.price * item.quantity,
            0
          ),
          itemCount: order.items.length,
        }));
      }

      // Add metadata
      cloned.metadata = {
        processedAt: new Date().toISOString(),
        version: "1.0",
      };

      return cloned;
    });

    setTransformedData(transformed);
  }, [sourceData]);

  return (
    <div className="data-table">
      {transformedData.map((item) => (
        <div key={item.id} className="data-row">
          <span>{item.fullName}</span>
          <span>{item.age} years old</span>
          <span>{item.orders?.length || 0} orders</span>
        </div>
      ))}
    </div>
  );
}
```

### State Comparison

```javascript
function useStateComparison(initialState) {
  const [currentState, setCurrentState] = useState(deepClone(initialState));
  const [previousState, setPreviousState] = useState(null);

  const updateState = useCallback(
    (newState) => {
      setPreviousState(deepClone(currentState));
      setCurrentState(deepClone(newState));
    },
    [currentState]
  );

  const hasChanged = useCallback(
    (path) => {
      if (!previousState) return false;

      const getCurrentValue = (obj, pathArray) => {
        return pathArray.reduce((acc, key) => acc?.[key], obj);
      };

      const pathArray = path.split(".");
      const currentValue = getCurrentValue(currentState, pathArray);
      const previousValue = getCurrentValue(previousState, pathArray);

      return JSON.stringify(currentValue) !== JSON.stringify(previousValue);
    },
    [currentState, previousState]
  );

  const getChanges = useCallback(() => {
    if (!previousState) return {};

    const changes = {};
    const findChanges = (current, previous, path = "") => {
      Object.keys(current).forEach((key) => {
        const currentPath = path ? `${path}.${key}` : key;
        const currentValue = current[key];
        const previousValue = previous?.[key];

        if (typeof currentValue === "object" && currentValue !== null) {
          findChanges(currentValue, previousValue, currentPath);
        } else if (currentValue !== previousValue) {
          changes[currentPath] = {
            from: previousValue,
            to: currentValue,
          };
        }
      });
    };

    findChanges(currentState, previousState);
    return changes;
  }, [currentState, previousState]);

  return {
    state: currentState,
    updateState,
    hasChanged,
    getChanges,
    previousState,
  };
}
```

### Template System

```javascript
function TemplateEngine() {
  const [templates, setTemplates] = useState({});

  const createTemplate = (name, template) => {
    setTemplates((prev) => ({
      ...prev,
      [name]: deepClone(template),
    }));
  };

  const useTemplate = (name, overrides = {}) => {
    const template = templates[name];
    if (!template) return null;

    const instance = deepClone(template);

    // Apply overrides recursively
    const applyOverrides = (target, source) => {
      Object.keys(source).forEach((key) => {
        if (
          typeof source[key] === "object" &&
          source[key] !== null &&
          !Array.isArray(source[key])
        ) {
          if (!target[key]) target[key] = {};
          applyOverrides(target[key], source[key]);
        } else {
          target[key] = source[key];
        }
      });
    };

    applyOverrides(instance, overrides);
    return instance;
  };

  return {
    createTemplate,
    useTemplate,
    templates: Object.keys(templates),
  };
}
```

## Notes

- Creates true deep copies, not shallow references
- Handles nested objects, arrays, and primitive values
- Essential for immutable state management patterns
- Prevents unintended mutations that can cause bugs
- More reliable than `JSON.parse(JSON.stringify())` for complex objects
- Use sparingly for performance-critical code due to recursive nature

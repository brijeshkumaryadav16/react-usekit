---
title: isEmpty
description: Check if values are empty (objects, arrays, strings, null, undefined)
---

# isEmpty

The `isEmpty` utility function checks if a value is considered empty. It handles various data types
including objects, arrays, strings, null, and undefined values, making it perfect for form
validation, conditional rendering, and data processing.

## Usage

```javascript
import { isEmpty } from './utils/isEmpty';

console.log(isEmpty('')); // true
console.log(isEmpty({})); // true
console.log(isEmpty([])); // true
console.log(isEmpty(null)); // true
console.log(isEmpty(undefined)); // true
console.log(isEmpty('hello')); // false
console.log(isEmpty({ name: 'John' })); // false
console.log(isEmpty([1, 2, 3])); // false
```

## API Reference

### Parameters

- `value` (any): The value to check for emptiness

### Returns

- `boolean`: `true` if the value is empty, `false` otherwise

## Examples

### Form Validation

```javascript
function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
  });
  const [errors, setErrors] = useState({});

  const validateForm = () => {
    const newErrors = {};

    if (isEmpty(formData.name)) {
      newErrors.name = 'Name is required';
    }

    if (isEmpty(formData.email)) {
      newErrors.email = 'Email is required';
    }

    if (isEmpty(formData.message)) {
      newErrors.message = 'Message is required';
    }

    setErrors(newErrors);
    return isEmpty(newErrors);
  };

  const handleSubmit = e => {
    e.preventDefault();
    if (validateForm()) {
      // Submit form
      console.log('Form is valid', formData);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name</label>
        <input
          value={formData.name}
          onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
        />
        {errors.name && <span className="error">{errors.name}</span>}
      </div>

      <div>
        <label>Email</label>
        <input
          type="email"
          value={formData.email}
          onChange={e => setFormData(prev => ({ ...prev, email: e.target.value }))}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>

      <div>
        <label>Message</label>
        <textarea
          value={formData.message}
          onChange={e => setFormData(prev => ({ ...prev, message: e.target.value }))}
        />
        {errors.message && <span className="error">{errors.message}</span>}
      </div>

      <button type="submit">Send Message</button>
    </form>
  );
}
```

### Conditional Rendering

```javascript
function UserProfile({ user }) {
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>

      {!isEmpty(user.avatar) && <img src={user.avatar} alt={user.name} />}

      {!isEmpty(user.bio) && <p className="bio">{user.bio}</p>}

      {!isEmpty(user.skills) && (
        <div className="skills">
          <h3>Skills</h3>
          <ul>
            {user.skills.map(skill => (
              <li key={skill}>{skill}</li>
            ))}
          </ul>
        </div>
      )}

      {!isEmpty(user.socialLinks) && (
        <div className="social-links">
          <h3>Connect</h3>
          {Object.entries(user.socialLinks).map(([platform, url]) => (
            <a key={platform} href={url} target="_blank" rel="noopener noreferrer">
              {platform}
            </a>
          ))}
        </div>
      )}
    </div>
  );
}
```

### API Response Handling

```javascript
function ProductList() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchProducts()
      .then(response => {
        if (isEmpty(response.data)) {
          setError('No products found');
        } else {
          setProducts(response.data);
        }
      })
      .catch(err => setError('Failed to load products'))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <div>Loading...</div>;

  if (error) return <div className="error">{error}</div>;

  if (isEmpty(products)) {
    return <div className="empty-state">No products available</div>;
  }

  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### Search and Filter

```javascript
function SearchableList({ items, searchTerm, filters }) {
  const filteredItems = useMemo(() => {
    let result = items;

    // Apply search filter
    if (!isEmpty(searchTerm)) {
      result = result.filter(
        item =>
          item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.description.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    // Apply category filter
    if (!isEmpty(filters.category)) {
      result = result.filter(item => item.category === filters.category);
    }

    // Apply price range filter
    if (!isEmpty(filters.priceRange)) {
      result = result.filter(
        item => item.price >= filters.priceRange.min && item.price <= filters.priceRange.max
      );
    }

    return result;
  }, [items, searchTerm, filters]);

  return (
    <div>
      {isEmpty(filteredItems) ? (
        <div className="no-results">
          <p>No items match your criteria</p>
          <button onClick={() => window.location.reload()}>Clear Filters</button>
        </div>
      ) : (
        <div className="results">
          {filteredItems.map(item => (
            <ItemCard key={item.id} item={item} />
          ))}
        </div>
      )}
    </div>
  );
}
```

### Data Processing

```javascript
function DataProcessor({ rawData }) {
  const processedData = useMemo(() => {
    if (isEmpty(rawData)) return [];

    return rawData
      .filter(item => !isEmpty(item.name) && !isEmpty(item.value))
      .map(item => ({
        ...item,
        hasMetadata: !isEmpty(item.metadata),
        hasChildren: !isEmpty(item.children),
        displayName: isEmpty(item.displayName) ? item.name : item.displayName,
      }))
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [rawData]);

  return (
    <div className="data-display">
      {isEmpty(processedData) ? (
        <div className="empty-data">
          <p>No valid data to display</p>
        </div>
      ) : (
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Value</th>
              <th>Has Metadata</th>
              <th>Has Children</th>
            </tr>
          </thead>
          <tbody>
            {processedData.map(item => (
              <tr key={item.id}>
                <td>{item.displayName}</td>
                <td>{item.value}</td>
                <td>{item.hasMetadata ? 'Yes' : 'No'}</td>
                <td>{item.hasChildren ? 'Yes' : 'No'}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}
```

### Form Field Validation

```javascript
function useFormValidation(initialValues, validationRules) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});

  const validate = useCallback(
    (fieldName, value) => {
      const rules = validationRules[fieldName];
      if (!rules) return '';

      if (rules.required && isEmpty(value)) {
        return `${fieldName} is required`;
      }

      if (rules.minLength && !isEmpty(value) && value.length < rules.minLength) {
        return `${fieldName} must be at least ${rules.minLength} characters`;
      }

      if (rules.custom && !isEmpty(value) && !rules.custom(value)) {
        return rules.customMessage || `${fieldName} is invalid`;
      }

      return '';
    },
    [validationRules]
  );

  const setValue = useCallback(
    (fieldName, value) => {
      setValues(prev => ({ ...prev, [fieldName]: value }));

      const error = validate(fieldName, value);
      setErrors(prev => ({
        ...prev,
        [fieldName]: error,
      }));
    },
    [validate]
  );

  const validateAll = useCallback(() => {
    const newErrors = {};

    Object.keys(validationRules).forEach(fieldName => {
      const error = validate(fieldName, values[fieldName]);
      if (!isEmpty(error)) {
        newErrors[fieldName] = error;
      }
    });

    setErrors(newErrors);
    return isEmpty(newErrors);
  }, [values, validate, validationRules]);

  return {
    values,
    errors,
    setValue,
    validateAll,
    isValid: isEmpty(errors),
  };
}
```

### Configuration Objects

```javascript
function ConfigProvider({ config, children }) {
  const processedConfig = useMemo(() => {
    const defaults = {
      theme: 'light',
      language: 'en',
      features: {
        notifications: true,
        analytics: false,
        experimental: false,
      },
    };

    if (isEmpty(config)) {
      return defaults;
    }

    return {
      theme: isEmpty(config.theme) ? defaults.theme : config.theme,
      language: isEmpty(config.language) ? defaults.language : config.language,
      features: {
        notifications: isEmpty(config.features?.notifications)
          ? defaults.features.notifications
          : config.features.notifications,
        analytics: isEmpty(config.features?.analytics)
          ? defaults.features.analytics
          : config.features.analytics,
        experimental: isEmpty(config.features?.experimental)
          ? defaults.features.experimental
          : config.features.experimental,
      },
    };
  }, [config]);

  return <ConfigContext.Provider value={processedConfig}>{children}</ConfigContext.Provider>;
}
```

## Notes

- Returns `true` for empty strings, arrays, objects, null, and undefined
- Returns `false` for numbers (including 0), booleans, and non-empty values
- For objects, checks if they have no enumerable properties
- For arrays, checks if the length is 0
- Perfect for validation, conditional rendering, and data processing
- Handles edge cases consistently across different data types

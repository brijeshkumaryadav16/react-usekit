---
title: Utilities
description: Essential utility functions for common operations
---

import { Callout } from "fumadocs-ui/components/callout";

# Utility Functions

<Callout>
  Production-ready utility functions that solve common problems. Each function
  is copy-pasted directly into your project - no dependencies, just code you
  own.
</Callout>

## Available Utilities

- **capitalize** - Make the first letter of a string uppercase
- **formatCurrency** - Format numbers as currency with locale support
- **isEmpty** - Check if values are empty (null, undefined, empty objects/arrays)
- **truncateText** - Truncate text with ellipsis at specified length
- **formatDate** - Format dates with customizable patterns
- **slugify** - Convert strings to URL-friendly slugs
- **generateId** - Generate unique identifiers for keys and IDs
- **deepClone** - Deep clone objects and arrays safely

---

## capitalize

**Make the first letter of a string uppercase**

```tsx
capitalize("hello world"); // "Hello world"
```

**What it does:** Converts the first character of a string to uppercase while keeping the rest unchanged.

**Basic Example:**

```tsx
function UserGreeting({ username }) {
  return <h1>Hello, {capitalize(username)}!</h1>;
}

// Usage: <UserGreeting username="john" /> → "Hello, John!"
```

**Advanced Example:**

```tsx
function ProductList({ products }) {
  return (
    <div>
      {products.map((product) => (
        <div key={product.id}>
          <h3>{capitalize(product.category)}</h3>
          <p>{capitalize(product.name)}</p>
        </div>
      ))}
    </div>
  );
}

// Converts: "smartphones" → "Smartphones", "laptops" → "Laptops"
```

---

## formatCurrency

**Format numbers as currency with locale support**

```tsx
formatCurrency(99.99); // "$99.99"
formatCurrency(99.99, "EUR"); // "€99.99"
```

**What it does:** Converts numbers into properly formatted currency strings with the correct symbols and decimal places.

**Basic Example:**

```tsx
function PriceDisplay({ price }) {
  return <span className="price">{formatCurrency(price)}</span>;
}

// Usage: <PriceDisplay price={29.99} /> → "$29.99"
```

**Advanced Example:**

```tsx
function InternationalPricing({ product, userLocale }) {
  const currencyMap = {
    US: "USD",
    EU: "EUR",
    UK: "GBP",
    JP: "JPY",
  };

  return (
    <div className="pricing">
      <h3>{product.name}</h3>
      <p>Price: {formatCurrency(product.price, currencyMap[userLocale])}</p>
      <p>Tax: {formatCurrency(product.price * 0.1, currencyMap[userLocale])}</p>
      <p>
        Total: {formatCurrency(product.price * 1.1, currencyMap[userLocale])}
      </p>
    </div>
  );
}
```

---

## isEmpty

**Check if values are empty (null, undefined, empty objects/arrays)**

```tsx
isEmpty(null); // true
isEmpty([]); // true
isEmpty({}); // true
isEmpty("hello"); // false
```

**What it does:** Safely checks if a value is empty, handling all the edge cases (null, undefined, empty arrays, empty objects, empty strings).

**Basic Example:**

```tsx
function UserProfile({ user }) {
  if (isEmpty(user)) {
    return <div>No user data available</div>;
  }

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

**Advanced Example:**

```tsx
function ContactForm() {
  const [form, setForm] = useState({ name: "", email: "", message: "" });
  const [errors, setErrors] = useState({});

  const validateForm = () => {
    const newErrors = {};

    if (isEmpty(form.name.trim())) {
      newErrors.name = "Name is required";
    }
    if (isEmpty(form.email.trim())) {
      newErrors.email = "Email is required";
    }
    if (isEmpty(form.message.trim())) {
      newErrors.message = "Message is required";
    }

    setErrors(newErrors);
    return isEmpty(newErrors); // Form is valid if no errors
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      console.log("Form submitted:", form);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={form.name}
        onChange={(e) => setForm({ ...form, name: e.target.value })}
        placeholder="Name"
      />
      {errors.name && <span className="error">{errors.name}</span>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## truncateText

**Truncate text with ellipsis**

```tsx
truncateText("This is a very long text", 10); // "This is a..."
```

**What it does:** Shortens text to a specified length and adds "..." at the end if the text was longer than the limit.

**Basic Example:**

```tsx
function ProductCard({ product }) {
  return (
    <div className="card">
      <h3>{truncateText(product.name, 20)}</h3>
      <p>{truncateText(product.description, 100)}</p>
    </div>
  );
}

// Long product names and descriptions are automatically shortened
```

**Advanced Example:**

```tsx
function CommentList({ comments }) {
  const [expandedComments, setExpandedComments] = useState(new Set());

  const toggleComment = (commentId) => {
    const newExpanded = new Set(expandedComments);
    if (newExpanded.has(commentId)) {
      newExpanded.delete(commentId);
    } else {
      newExpanded.add(commentId);
    }
    setExpandedComments(newExpanded);
  };

  return (
    <div>
      {comments.map((comment) => (
        <div key={comment.id} className="comment">
          <h4>{comment.author}</h4>
          <p>
            {expandedComments.has(comment.id)
              ? comment.text
              : truncateText(comment.text, 150)}
            {comment.text.length > 150 && (
              <button onClick={() => toggleComment(comment.id)}>
                {expandedComments.has(comment.id) ? "Show less" : "Show more"}
              </button>
            )}
          </p>
        </div>
      ))}
    </div>
  );
}
```

---

## formatDate

**Format dates with customizable patterns**

```tsx
formatDate(new Date()); // "Jan 1, 2024"
formatDate(new Date(), "short"); // "1/1/24"
```

**What it does:** Converts Date objects into human-readable strings with various formatting options.

**Basic Example:**

```tsx
function BlogPost({ post }) {
  return (
    <article>
      <h2>{post.title}</h2>
      <p className="meta">Published on {formatDate(post.publishedAt)}</p>
      <div>{post.content}</div>
    </article>
  );
}
```

**Advanced Example:**

```tsx
function EventCalendar({ events }) {
  const groupEventsByDate = (events) => {
    return events.reduce((groups, event) => {
      const dateKey = formatDate(event.date, "short");
      if (!groups[dateKey]) groups[dateKey] = [];
      groups[dateKey].push(event);
      return groups;
    }, {});
  };

  const groupedEvents = groupEventsByDate(events);

  return (
    <div className="calendar">
      {Object.entries(groupedEvents).map(([date, dayEvents]) => (
        <div key={date} className="day">
          <h3>{date}</h3>
          {dayEvents.map((event) => (
            <div key={event.id} className="event">
              <span className="time">{formatDate(event.date, "time")}</span>
              <span className="title">{event.title}</span>
            </div>
          ))}
        </div>
      ))}
    </div>
  );
}
```

---

## slugify

**Convert strings to URL-friendly slugs**

```tsx
slugify("Hello World!"); // "hello-world"
slugify("My Blog Post #1"); // "my-blog-post-1"
```

**What it does:** Converts any string into a URL-safe slug by removing special characters, converting to lowercase, and replacing spaces with hyphens.

**Basic Example:**

```tsx
function BlogLink({ title }) {
  const slug = slugify(title);

  return <a href={`/blog/${slug}`}>{title}</a>;
}

// "How to Learn React" → "/blog/how-to-learn-react"
```

**Advanced Example:**

```tsx
function ContentManager() {
  const [articles, setArticles] = useState([]);
  const [newTitle, setNewTitle] = useState("");

  const addArticle = () => {
    const slug = slugify(newTitle);
    const newArticle = {
      id: generateId(),
      title: newTitle,
      slug: slug,
      url: `/articles/${slug}`,
      createdAt: new Date(),
    };

    setArticles([...articles, newArticle]);
    setNewTitle("");
  };

  return (
    <div>
      <input
        value={newTitle}
        onChange={(e) => setNewTitle(e.target.value)}
        placeholder="Article title"
      />
      <p>URL preview: /articles/{slugify(newTitle)}</p>
      <button onClick={addArticle}>Add Article</button>

      <div className="articles">
        {articles.map((article) => (
          <div key={article.id}>
            <h3>{article.title}</h3>
            <a href={article.url}>View Article</a>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## generateId

**Generate unique identifiers**

```tsx
const id = generateId(); // "abc123def"
const longId = generateId(16); // "abc123def456ghi7"
```

**What it does:** Creates random, unique strings that can be used as IDs, keys, or temporary identifiers.

**Basic Example:**

```tsx
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState("");

  const addTodo = () => {
    if (newTodo.trim()) {
      setTodos([
        ...todos,
        {
          id: generateId(),
          text: newTodo,
          completed: false,
        },
      ]);
      setNewTodo("");
    }
  };

  return (
    <div>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
        placeholder="Add a todo"
      />
      <button onClick={addTodo}>Add</button>

      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Advanced Example:**

```tsx
function FileUploader() {
  const [uploads, setUploads] = useState([]);

  const handleFileSelect = (files) => {
    const newUploads = Array.from(files).map((file) => ({
      id: generateId(),
      file,
      progress: 0,
      status: "pending",
      uploadedAt: null,
    }));

    setUploads((prev) => [...prev, ...newUploads]);

    // Start uploading each file
    newUploads.forEach((upload) => {
      uploadFile(upload.id, upload.file);
    });
  };

  const uploadFile = async (uploadId, file) => {
    // Simulate file upload with progress
    for (let progress = 0; progress <= 100; progress += 10) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      setUploads((prev) =>
        prev.map((upload) =>
          upload.id === uploadId
            ? {
                ...upload,
                progress,
                status: progress === 100 ? "completed" : "uploading",
              }
            : upload
        )
      );
    }
  };

  return (
    <div>
      <input
        type="file"
        multiple
        onChange={(e) => handleFileSelect(e.target.files)}
      />

      <div className="uploads">
        {uploads.map((upload) => (
          <div key={upload.id} className="upload-item">
            <span>{upload.file.name}</span>
            <div className="progress">
              <div
                className="progress-bar"
                style={{ width: `${upload.progress}%` }}
              />
            </div>
            <span>{upload.status}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## deepClone

**Deep clone objects and arrays safely**

```tsx
const original = { user: { name: "John", preferences: { theme: "dark" } } };
const cloned = deepClone(original);
```

**What it does:** Creates a completely independent copy of complex objects and arrays, including nested structures.

**Basic Example:**

```tsx
function UserSettings() {
  const [settings, setSettings] = useState({
    profile: { name: "John", email: "john@example.com" },
    preferences: { theme: "light", notifications: true },
  });

  const [tempSettings, setTempSettings] = useState(null);

  const startEditing = () => {
    // Create a deep clone for editing without affecting original
    setTempSettings(deepClone(settings));
  };

  const saveChanges = () => {
    setSettings(tempSettings);
    setTempSettings(null);
  };

  const cancelChanges = () => {
    setTempSettings(null);
  };

  return (
    <div>
      {tempSettings ? (
        <div>
          <h3>Editing Settings</h3>
          <input
            value={tempSettings.profile.name}
            onChange={(e) =>
              setTempSettings({
                ...tempSettings,
                profile: { ...tempSettings.profile, name: e.target.value },
              })
            }
          />
          <button onClick={saveChanges}>Save</button>
          <button onClick={cancelChanges}>Cancel</button>
        </div>
      ) : (
        <div>
          <h3>Current Settings</h3>
          <p>Name: {settings.profile.name}</p>
          <button onClick={startEditing}>Edit</button>
        </div>
      )}
    </div>
  );
}
```
